cpp可以自己调自己，与C不同，cpp不允许main()调用自己，这种功能被称为递归。
![[recursion.png]]

1.包含一个[递归调用](https://so.csdn.net/so/search?q=%E9%80%92%E5%BD%92%E8%B0%83%E7%94%A8&spm=1001.2101.3001.7020)的递归

如果[递归函数](https://so.csdn.net/so/search?q=%E9%80%92%E5%BD%92%E5%87%BD%E6%95%B0&spm=1001.2101.3001.7020)调用自己，则被调用的函数也将调用自己，这将无限循环下去，除非代码中包含终止调用链的内容，通常的方法将递归调用放在if语句中，例如：
```cpp
void recurs(argumentlist)
{
 
    statements1
    if (test)
        recurs(arguments)
    statements2
}
```
```cpp
#include <iostream>
void countdown(int n);
 
int main()
{
    countdown(4);           // call the recursive function
    // std::cin.get();
    return 0;
}
 
void countdown(int n)
{
    using namespace std;
    cout << "Counting down ... " << n << endl;
    if (n > 0)
        countdown(n-1);     // function calls itself
    cout << n << ": Kaboom!\n";
}
```

2.包含多个递归调用的递归

[递归方法](https://so.csdn.net/so/search?q=%E9%80%92%E5%BD%92%E6%96%B9%E6%B3%95&spm=1001.2101.3001.7020)有时被称为分而治之策略。

```cpp
#include <iostream>
const int Len = 66;
const int Divs = 6;
void subdivide(char ar[], int low, int high, int level);
int main()
{
    char ruler[Len];
    int i;
    for (i = 1; i < Len - 2; i++)
        ruler[i] = ' ';
    ruler[Len - 1] = '\0';
    int max = Len - 2;
    int min = 0;
    ruler[min] = ruler[max] = '|';
    std::cout << ruler << std::endl;
    for (i = 1; i <= Divs; i++)
    {
        subdivide(ruler,min,max, i);
        std::cout << ruler << std::endl;
        for (int j = 1; j < Len - 2; j++)
            ruler[j] = ' ';  // reset to blank ruler
    }
    // std::cin.get();
 
    return 0;
}
 
void subdivide(char ar[], int low, int high, int level)
{
    if (level == 0)
        return;
    int mid = (high + low) / 2;
    ar[mid] = '|';
    subdivide(ar, low, mid, level - 1);
    subdivide(ar, mid, high, level - 1); 
}
```