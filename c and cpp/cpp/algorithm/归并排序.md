【数据结构合集 - 归并排序(非递归与递归算法过程, 效率分析, 稳定性分析)】 https://www.bilibili.com/video/BV1em1oYTEFf/?share_source=copy_web&vd_source=713bb336b1ceaceae77fc25f3350e982

归并排序是一种基于**分治思想**的高效排序算法，由约翰·冯·诺伊曼于1945年提出。它的时间复杂度为O(n log n)，是一种稳定的排序算法。

# 基本思想
归并排序的核心思想是**"分而治之"**：
1. **分（Divide）**：将数组递归地分成两半，直到每个子数组只有一个元素
2. **治（Conquer）**：将两个已排序的子数组合并成一个有序数组

# 算法特性
- **时间复杂度**：
    - 最优：O(n log n)
    - 平均：O(n log n)
    - 最差：O(n log n)
- **空间复杂度**：O(n)（需要额外空间）
- **稳定性**：稳定（相同元素的相对位置不变）
- **适用性**：特别适合链表排序和大数据排序


# C++实现
## 递归版本
```cpp
#include <vector>
using namespace std;

void merge(vector<int>& arr, int left, int mid, int right) {
    vector<int> temp(right - left + 1);
    int i = left, j = mid + 1, k = 0;
    
    // 合并两个有序数组
    while (i <= mid && j <= right) {
        if (arr[i] <= arr[j]) {
            temp[k++] = arr[i++];
        } else {
            temp[k++] = arr[j++];
        }
    }
    
    // 处理剩余元素
    while (i <= mid) temp[k++] = arr[i++];
    while (j <= right) temp[k++] = arr[j++];
    
    // 拷贝回原数组
    for (int p = 0; p < k; p++) {
        arr[left + p] = temp[p];
    }
}

void mergeSort(vector<int>& arr, int left, int right) {
    if (left >= right) return;
    
    int mid = left + (right - left) / 2;
    mergeSort(arr, left, mid);     // 排序左半部分
    mergeSort(arr, mid + 1, right); // 排序右半部分
    merge(arr, left, mid, right);   // 合并两个有序部分
}
```
## 迭代版本（非递归）
```cpp
void mergeSortIterative(vector<int>& arr) {
    int n = arr.size();
    for (int curr_size = 1; curr_size <= n-1; curr_size *= 2) {
        for (int left = 0; left < n-1; left += 2*curr_size) {
            int mid = min(left + curr_size - 1, n-1);
            int right = min(left + 2*curr_size - 1, n-1);
            merge(arr, left, mid, right);
        }
    }
}
```

