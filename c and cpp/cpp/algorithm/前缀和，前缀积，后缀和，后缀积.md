# 前缀和
【前缀和及其变种，十道题检验你是不是真的学会了】 https://www.bilibili.com/video/BV1xKfyY9EkN/?share_source=copy_web&vd_source=713bb336b1ceaceae77fc25f3350e982

前缀和是一种重要的数据预处理技术，可以高效地解决数组区间求和问题。

## 什么是前缀和？

前缀和是指将数组中每个位置的值表示为从数组起始位置到当前位置的所有元素的和。通过预处理计算前缀和数组，我们可以在O(1)时间内计算任意区间的和。

## 前缀和的优势

- **高效查询**：可以在O(1)时间内查询任意区间的和
    
- **预处理简单**：只需要O(n)时间预处理
    
- **应用广泛**：

```cpp
#include <iostream>
#include <vector>

using namespace std;

vector<int> computePrefixSum(const vector<int>& nums) {
    int n = nums.size();
    vector<int> prefix(n + 1, 0);  // prefix[0] = 0
    
    for (int i = 1; i <= n; ++i) {
        prefix[i] = prefix[i - 1] + nums[i - 1];
    }
    
    return prefix;
}

int rangeSum(const vector<int>& prefix, int l, int r) {
    // 查询区间[l, r]的和，l和r从0开始
    return prefix[r + 1] - prefix[l];
}

int main() {
    vector<int> nums = {1, 2, 3, 4, 5};
    vector<int> prefix = computePrefixSum(nums);
    
    cout << "Prefix sum array: ";
    for (int num : prefix) {
        cout << num << " ";
    }
    cout << endl;
    
    cout << "Sum of [1,3]: " << rangeSum(prefix, 1, 3) << endl;  // 2+3+4=9
    cout << "Sum of [0,4]: " << rangeSum(prefix, 0, 4) << endl;  // 1+2+3+4+5=15
    
    return 0;
}
```

## 应用场景

1. 频繁查询数组区间和
    
2. 解决子数组和问题（如和为k的子数组）
    
3. 二维数组的矩形区域求和
    
4. 配合哈希表解决更复杂的问题

## 二维前缀和

前缀和也可以扩展到二维情况，用于快速计算矩阵中子矩阵的和：

```cpp
vector<vector<int>> compute2DPrefixSum(const vector<vector<int>>& matrix) {
    int m = matrix.size(), n = matrix[0].size();
    vector<vector<int>> prefix(m + 1, vector<int>(n + 1, 0));
    
    for (int i = 1; i <= m; ++i) {
        for (int j = 1; j <= n; ++j) {
            prefix[i][j] = prefix[i-1][j] + prefix[i][j-1] - prefix[i-1][j-1] + matrix[i-1][j-1];
        }
    }
    
    return prefix;
}

int rangeSum2D(const vector<vector<int>>& prefix, int row1, int col1, int row2, int col2) {
    return prefix[row2+1][col2+1] - prefix[row1][col2+1] - prefix[row2+1][col1] + prefix[row1][col1];
}
```

C++17 引入了 `<numeric>` 中的 `std::partial_sum`，可以方便地计算前缀和。

## **1. 使用 `std::partial_sum`（C++标准库）**

`std::partial_sum` 计算前缀和，并存储到目标容器中：
```cpp
#include <iostream>
#include <vector>
#include <numeric> // for std::partial_sum

int main() {
    std::vector<int> nums = {1, 2, 3, 4, 5};
    std::vector<int> prefix(nums.size());

    // 计算前缀和
    std::partial_sum(nums.begin(), nums.end(), prefix.begin());

    // 输出前缀和数组
    for (int num : prefix) {
        std::cout << num << " ";
    }
    // 输出: 1 3 6 10 15

    return 0;
}
```

**特点**：
- **直接计算前缀和**，无需手动实现循环。
- 可以自定义操作（如乘法、位运算等）：
```cpp
std::partial_sum(nums.begin(), nums.end(), prefix.begin(), std::multiplies<int>());
```
## **2. 使用 `std::inclusive_scan`（C++17 并行计算）**

如果支持 C++17，可以使用 `std::inclusive_scan` 进行更灵活的前缀和计算（支持并行）：
```cpp
#include <iostream>
#include <vector>
#include <numeric> // for std::inclusive_scan

int main() {
    std::vector<int> nums = {1, 2, 3, 4, 5};
    std::vector<int> prefix(nums.size());

    // 计算前缀和（可以指定并行策略）
    std::inclusive_scan(nums.begin(), nums.end(), prefix.begin());

    for (int num : prefix) {
        std::cout << num << " ";
    }
    // 输出: 1 3 6 10 15

    return 0;
}
```

**特点**：
- 类似于 `std::partial_sum`，但支持并行计算（如 `std::execution::par`）。
- 可以自定义运算符（如 `std::plus<>` 或自定义函数）。

# 前缀积

# 后缀积
后缀积是指数组中从某个位置开始到数组末尾所有元素的乘积。类似于后缀和的概念，但使用的是乘法运算而非加法。
## 定义

对于一个长度为 n 的数组 nums，它的后缀积数组 suffixProd 定义为：
- `suffixProd[i] = nums[i] × nums[i+1] × ... × nums[n-1] `

特别地：
- `suffixProd[n-1] = nums[n-1]` (最后一个元素的后缀积就是它本身)
    
- `suffixProd[0]` 是整个数组所有元素的乘积

# 前缀后缀积分解
```cpp
class Solution {

public:

vector<int> productExceptSelf(vector<int>& nums) {

int n = nums.size();

int pro_product = 1;

deque<int> pro_product_set;

for(int i = n - 1; i >= 0; i--){

pro_product = pro_product * nums[i];

pro_product_set.push_front(pro_product);

}

int pre_product = 1;

deque<int> pre_product_set;

for(int i = 0; i < n; i++){

pre_product = pre_product * nums[i];

pre_product_set.push_back(pre_product);

}

  

vector<int> res(n);

  

for(int i = 0; i < n; i++){

if( i == 0){

res[i] = pro_product_set[i + 1];

}

else if(i == n-1){

res[i] = pre_product_set[i - 1];

}

else{

res[i] = pro_product_set[i + 1]*pre_product_set[i - 1];

}

}

return res;

}

};
```
